diff --git a/node_modules/next/dist/build/utils.js b/node_modules/next/dist/build/utils.js
index 8646fd5..6df3623 100644
--- a/node_modules/next/dist/build/utils.js
+++ b/node_modules/next/dist/build/utils.js
@@ -19,7 +19,7 @@ const _validParamKeys=Object.keys(_routeMatcher(page));const staticPathsResult=a
 // route.
 if(typeof entry==='string'){const result=_routeMatcher(entry);if(!result){throw new Error(`The provided path \`${entry}\` does not match the page: \`${page}\`.`);}prerenderPaths===null||prerenderPaths===void 0?void 0:prerenderPaths.add(entry);}// For the object-provided path, we must make sure it specifies all
 // required keys.
-else{const invalidKeys=Object.keys(entry).filter(key=>key!=='params');if(invalidKeys.length){throw new Error(`Additional keys were returned from \`getStaticPaths\` in page "${page}". `+`URL Parameters intended for this dynamic route must be nested under the \`params\` key, i.e.:`+`\n\n\treturn { params: { ${_validParamKeys.map(k=>`${k}: ...`).join(', ')} } }`+`\n\nKeys that need to be moved: ${invalidKeys.join(', ')}.\n`);}const{params={}}=entry;let builtPage=page;_validParamKeys.forEach(validParamKey=>{const{repeat}=_routeRegex.groups[validParamKey];const paramValue=params[validParamKey];if(repeat&&!Array.isArray(paramValue)||!repeat&&typeof paramValue!=='string'){throw new Error(`A required parameter (${validParamKey}) was not provided as ${repeat?'an array':'a string'} in getStaticPaths for ${page}`);}builtPage=builtPage.replace(`[${repeat?'...':''}${validParamKey}]`,repeat?paramValue.map(encodeURIComponent).join('/'):encodeURIComponent(paramValue));});prerenderPaths===null||prerenderPaths===void 0?void 0:prerenderPaths.add(builtPage);}});return{paths:[...prerenderPaths],fallback:staticPathsResult.fallback};}async function isPageStatic(page,serverBundle,runtimeEnvConfig){try{require('../next-server/lib/runtime-config').setConfig(runtimeEnvConfig);const mod=require(serverBundle);const Comp=mod.default||mod;if(!Comp||!(0,_reactIs.isValidElementType)(Comp)||typeof Comp==='string'){throw new Error('INVALID_DEFAULT_EXPORT');}const hasGetInitialProps=!!Comp.getInitialProps;const hasStaticProps=!!mod.getStaticProps;const hasStaticPaths=!!mod.getStaticPaths;const hasServerProps=!!mod.getServerSideProps;const hasLegacyServerProps=!!mod.unstable_getServerProps;const hasLegacyStaticProps=!!mod.unstable_getStaticProps;const hasLegacyStaticPaths=!!mod.unstable_getStaticPaths;const hasLegacyStaticParams=!!mod.unstable_getStaticParams;if(hasLegacyStaticParams){throw new Error(`unstable_getStaticParams was replaced with getStaticPaths. Please update your code.`);}if(hasLegacyStaticPaths){throw new Error(`unstable_getStaticPaths was replaced with getStaticPaths. Please update your code.`);}if(hasLegacyStaticProps){throw new Error(`unstable_getStaticProps was replaced with getStaticProps. Please update your code.`);}if(hasLegacyServerProps){throw new Error(`unstable_getServerProps was replaced with getServerSideProps. Please update your code.`);}// A page cannot be prerendered _and_ define a data requirement. That's
+else{const invalidKeys=Object.keys(entry).filter(key=>key!=='params');if(invalidKeys.length){throw new Error(`Additional keys were returned from \`getStaticPaths\` in page "${page}". `+`URL Parameters intended for this dynamic route must be nested under the \`params\` key, i.e.:`+`\n\n\treturn { params: { ${_validParamKeys.map(k=>`${k}: ...`).join(', ')} } }`+`\n\nKeys that need to be moved: ${invalidKeys.join(', ')}.\n`);}const{params={}}=entry;let builtPage=page;_validParamKeys.forEach(validParamKey=>{const{repeat}=_routeRegex.groups[validParamKey];const paramValue=params[validParamKey];if(repeat&&!Array.isArray(paramValue)||!repeat&&typeof paramValue!=='string'){throw new Error(`A required parameter (${validParamKey}) was not provided as ${repeat?'an array':'a string'} in getStaticPaths for ${page}`);}builtPage=builtPage.replace(`[${repeat?'...':''}${validParamKey}]`,repeat?paramValue.map(encodeURIComponent).join('/'):encodeURIComponent(paramValue));});prerenderPaths===null||prerenderPaths===void 0?void 0:prerenderPaths.add(builtPage);}});return{paths:[...prerenderPaths],fallback:staticPathsResult.fallback};}async function isPageStatic(page,serverBundle,runtimeEnvConfig){if (typeof require !== 'undefined') require.extensions['.less'] = () => {};try{require('../next-server/lib/runtime-config').setConfig(runtimeEnvConfig);const mod=require(serverBundle);const Comp=mod.default||mod;if(!Comp||!(0,_reactIs.isValidElementType)(Comp)||typeof Comp==='string'){throw new Error('INVALID_DEFAULT_EXPORT');}const hasGetInitialProps=!!Comp.getInitialProps;const hasStaticProps=!!mod.getStaticProps;const hasStaticPaths=!!mod.getStaticPaths;const hasServerProps=!!mod.getServerSideProps;const hasLegacyServerProps=!!mod.unstable_getServerProps;const hasLegacyStaticProps=!!mod.unstable_getStaticProps;const hasLegacyStaticPaths=!!mod.unstable_getStaticPaths;const hasLegacyStaticParams=!!mod.unstable_getStaticParams;if(hasLegacyStaticParams){throw new Error(`unstable_getStaticParams was replaced with getStaticPaths. Please update your code.`);}if(hasLegacyStaticPaths){throw new Error(`unstable_getStaticPaths was replaced with getStaticPaths. Please update your code.`);}if(hasLegacyStaticProps){throw new Error(`unstable_getStaticProps was replaced with getStaticProps. Please update your code.`);}if(hasLegacyServerProps){throw new Error(`unstable_getServerProps was replaced with getServerSideProps. Please update your code.`);}// A page cannot be prerendered _and_ define a data requirement. That's
 // contradictory!
 if(hasGetInitialProps&&hasStaticProps){throw new Error(_constants.SSG_GET_INITIAL_PROPS_CONFLICT);}if(hasGetInitialProps&&hasServerProps){throw new Error(_constants.SERVER_PROPS_GET_INIT_PROPS_CONFLICT);}if(hasStaticProps&&hasServerProps){throw new Error(_constants.SERVER_PROPS_SSG_CONFLICT);}const pageIsDynamic=(0,_isDynamic.isDynamicRoute)(page);// A page cannot have static parameters if it is not a dynamic page.
 if(hasStaticProps&&hasStaticPaths&&!pageIsDynamic){throw new Error(`getStaticPaths can only be used with dynamic pages, not '${page}'.`+`\nLearn more: https://nextjs.org/docs#dynamic-routing`);}if(hasStaticProps&&pageIsDynamic&&!hasStaticPaths){throw new Error(`getStaticPaths is required for dynamic SSG pages and is missing for '${page}'.`+`\nRead more: https://err.sh/next.js/invalid-getstaticpaths-value`);}let prerenderRoutes;let prerenderFallback;if(hasStaticProps&&hasStaticPaths){;({paths:prerenderRoutes,fallback:prerenderFallback}=await buildStaticPaths(page,mod.getStaticPaths));}const config=mod.config||{};return{isStatic:!hasStaticProps&&!hasGetInitialProps&&!hasServerProps,isHybridAmp:config.amp==='hybrid',isAmpOnly:config.amp===true,prerenderRoutes,prerenderFallback,hasStaticProps,hasServerProps};}catch(err){if(err.code==='MODULE_NOT_FOUND')return{};throw err;}}function hasCustomGetInitialProps(bundle,runtimeEnvConfig,checkingApp){require('../next-server/lib/runtime-config').setConfig(runtimeEnvConfig);let mod=require(bundle);if(checkingApp){mod=mod._app||mod.default||mod;}else{mod=mod.default||mod;}return mod.getInitialProps!==mod.origGetInitialProps;}function getNamedExports(bundle,runtimeEnvConfig){require('../next-server/lib/runtime-config').setConfig(runtimeEnvConfig);return Object.keys(require(bundle));}
diff --git a/node_modules/next/dist/export/worker.js b/node_modules/next/dist/export/worker.js
index 5933ece..0b21a0d 100644
--- a/node_modules/next/dist/export/worker.js
+++ b/node_modules/next/dist/export/worker.js
@@ -1,5 +1,6 @@
 "use strict";exports.__esModule=true;exports.default=exportPage;var _url=_interopRequireDefault(require("url"));var _path=require("path");var _render=require("../next-server/server/render");var _fs=require("fs");var _amphtmlValidator=_interopRequireDefault(require("next/dist/compiled/amphtml-validator"));var _loadComponents=require("../next-server/server/load-components");var _isDynamic=require("../next-server/lib/router/utils/is-dynamic");var _routeMatcher=require("../next-server/lib/router/utils/route-matcher");var _routeRegex=require("../next-server/lib/router/utils/route-regex");var _normalizePagePath=require("../next-server/server/normalize-page-path");var _constants=require("../lib/constants");require("next/dist/next-server/server/node-polyfill-fetch");function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}const envConfig=require('../next-server/lib/runtime-config');global.__NEXT_DATA__={nextExport:true};async function exportPage({path,pathMap,distDir,buildId,outDir,pagesDataDir,renderOpts,buildExport,serverRuntimeConfig,subFolders,serverless}){let results={ampValidations:[]};try{const{query:originalQuery={}}=pathMap;const{page}=pathMap;const filePath=(0,_normalizePagePath.normalizePagePath)(path);const ampPath=`${filePath}.amp`;let query={...originalQuery};let params;// We need to show a warning if they try to provide query values
 // for an auto-exported page since they won't be available
+if (typeof require !== 'undefined') require.extensions['.less'] = () => {};
 const hasOrigQueryValues=Object.keys(originalQuery).length>0;const queryWithAutoExportWarn=()=>{if(hasOrigQueryValues){throw new Error(`\nError: you provided query values for ${path} which is an auto-exported page. These can not be applied since the page can no longer be re-rendered on the server. To disable auto-export for this page add \`getInitialProps\`\n`);}};// Check if the page is a specified dynamic route
 if((0,_isDynamic.isDynamicRoute)(page)&&page!==path){params=(0,_routeMatcher.getRouteMatcher)((0,_routeRegex.getRouteRegex)(page))(path)||undefined;if(params){// we have to pass these separately for serverless
 if(!serverless){query={...query,...params};}}else{throw new Error(`The provided export path '${path}' doesn't match the '${page}' page.\nRead more: https://err.sh/vercel/next.js/export-path-mismatch`);}}const headerMocks={headers:{},getHeader:()=>({}),setHeader:()=>{},hasHeader:()=>false,removeHeader:()=>{},getHeaderNames:()=>[]};const req={url:path,...headerMocks};const res={...headerMocks};envConfig.setConfig({serverRuntimeConfig,publicRuntimeConfig:renderOpts.runtimeConfig});let htmlFilename=`${filePath}${_path.sep}index.html`;if(!subFolders)htmlFilename=`${filePath}.html`;const pageExt=(0,_path.extname)(page);const pathExt=(0,_path.extname)(path);// Make sure page isn't a folder with a dot in the name e.g. `v1.2`